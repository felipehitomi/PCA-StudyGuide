# Metrics

Data:

---

Título: Metrics

---

Tópicos: [PCA](../PCA%20cd9096bcdf954863a10bfe439deac163.md) 

---

Links Usados:

**[Observability 101: Terminology and Concepts](https://www.honeycomb.io/blog/observability-101-terminology-and-concepts/)**

**[Introduction to open source observability on Kubernetes](https://opensource.com/article/19/10/open-source-observability-kubernetes)**

[https://prometheus.io/docs/concepts/metric_types/](https://prometheus.io/docs/concepts/metric_types/)

[https://grafana.com/blog/2022/03/01/how-summary-metrics-work-in-prometheus/](https://grafana.com/blog/2022/03/01/how-summary-metrics-work-in-prometheus/)

[https://grafana.com/blog/2022/03/01/how-summary-metrics-work-in-prometheus/](https://grafana.com/blog/2022/03/01/how-summary-metrics-work-in-prometheus/)[https://www.robustperception.io/how-does-a-prometheus-histogram-work/](https://www.robustperception.io/how-does-a-prometheus-histogram-work/)

---

Links a Usar:

---

Refs: Documentação do Prometheus

---

Observability- ***novas perguntas sobre seus sistemas sem  novas instrumentações***

The term comes from [control theory](https://en.wikipedia.org/wiki/Control_theory), which defines observability as the ability to understand the internal state of a system from its external outputs

**Telemetry**
consists of those “outputs”—it’s the data generated by your system that documents its state. Telemetry gets generated because of **instrumentation**: code or tooling that captures data about the state of your running system and stores it in various formats. Some examples of software telemetry include: metrics, logs, traces, and structured events.

The types of issues we often see in modern production software systems are emergent failure modes, which happen when a bunch of unlikely events line up to degrade or take down your system. They're really interesting but difficult to debug, which is why we need observability.

In order to have good observability into your software services, you need both good instrumentation generating high-context telemetry data, and you need sophisticated ways of interacting with that data that enable asking novel questions—questions you couldn’t have thought of when you wrote the code. Put more simply, software observability requires good data and good tooling. Let’s start by discussing the data.

***Conseguir fazer perguntas com os dados que você obteve é essencial***

telemetry is data that your system generates that tells you about the system's health, ***as vezes até um console.log é um dado de telemetria***

***as formas comuns de telemetria abaixo***

**Metrics**

Traditional monitoring uses system-level metrics to track things like CPU, memory, and disk performance. This data is important for choosing among virtual machine instance types, with options for processor speed, RAM, and hard disk storage. But it doesn’t tell you about user experience, or how to improve the performance of your code. ***Bom mas sem muita informação do usuário***

Modern monitoring services also provide application performance monitoring (APM) features, which track application-level metrics like average page load times, requests per second, and error rates. Each metric only tracks one variable, which makes them cheap to send and store. Values are pre-aggregated at write-time, however, so you need to deploy a code change if you want to track metrics for a new intersection of data, e.g. error rates for a specific user. ***O Apm é quando se foca a monitoração para a aplicação, precisa de modificação em codigo se você quer informação nova.*** 

O que precisa ter em uma métrica

1. Some identifier, hopefully descriptive, that indicates what the metric represents
2. A series of data points, each of which contains two elements:	
    1. The timestamp at which the data point was generated (or ingested)	
    2. A numeric value representing the state of the thing you're measuring at that time

Understanding the health and state of your infrastructure, platform, and service is essential to keeping them available to users. Generally, these are emitted by the various components chosen to build services, and it's just a matter of setting up the right collection and storage infrastructure to be able to use them. Metrics from the simple (node CPU utilization) to the esoteric (garbage collection statistics) fall into this category.

Metrics are also essential to understanding what is happening in the system to avoid interruptions to your services. From this perspective, a service can emit custom telemetry that precisely describes specific aspects of how the service is functioning and performing. This will require you to instrument the code itself, usually by including specific libraries, and specify an export destination.

******************************************************Voce pode tirar tanto informações sobre a saude de um sistema quanto tirar novas informações, exemplo se o numero de conexões está crescendo e será necessário subir mais instancias ou etc.****************************************************** 

**Logs**

Logs are text strings written to the terminal or to a file (often referred to as a “flat” log file). Logs can be any arbitrary string, but programming languages and frameworks have libraries to generate logs from your running code with relevant data at different levels of specificity (e.g. INFO vs. DEBUG mode). There’s no standardization among programming communities about what should get included at each log level.

Log aggregation services allow you to send the content of your logs and store them for later retrieval. Querying flat logs (as opposed to structured logs) is slow because of the computational complexity of indexing and parsing strings, which makes these tools impractical for debugging and investigating your production code in near-realtime. ***Buscar informações em logs não estruturados, ou seja, com um jeito pre definido, é muito complexo e custoso.*** 

**Traces**

A trace is a visualization of the events in your system showing the calling relationship between parent and child events as well as timing data for each event. The individual events that form a trace are called spans. Each span stores the start time, duration, and parent_id. Spans without a parent_id are rendered as root spans.

A distributed trace connects calling relationships among events in distributed services. For example, Service A calls Service B, which makes a database query and then hits a third-party API.

***Trabalha com a relação entre chamadas, geralmente colocando o tempo que durou e qual foi o que a chamou, ou se ela é a raiz, o que chamou. ex um banco de dados.*** 

**Structured Events**

A structured event is a data format that allows you store key-value pairs for an arbitrary number of fields or dimensions, often in JSON format. At minimum, structured events usually have a timestamp and a name field. Instrumentation libraries can automatically add other relevant data like the request endpoint, the user-agent, or the database query.

When we talk about wide events, we mean structured events with lots of fields. You can add whatever fields you want, and because they’re key-value pairs, it’s easy to query for them later on.

Events can be built into traces by pointing each event to its parent event with the parent_id field.

***Você armazena em chave valor, tendo um nome e um timestamp, pode-se colocar quantos quiser porque são chaves valores.*** 

**Telemetry concepts**

Context refers to the collection of additional dimensions, fields, or tags on a piece of data that tells you more about the internal state of your system. Context can include metadata, system-level metrics, and domain-specific information about the running program. ***Contexto são mais informações sobre um dado que tem como objetivo informar sobre o estado interno***

The dimensionality of data refers to how many fields or attributes a piece of data has attached to it. Examples of low-dimensionality data include metrics and flat logs. High-dimensionality data includes anything that can support many fields or attributes, including JSON blobs, structs, and objects. ***A dimensionalidade já tem mais haver com a quantidade de informações que tem, os campos*** 

The term cardinality refers to how many possible values a dimension can have. Some examples of low-cardinality data include booleans (true/false) and days of the week. High-cardinality examples are first name, social security number, UUID, or build ID. ***Cardinalidade está relacionado ao tamanho de valores possíveis. Tomar muito cuidado aqui, porque pode-se criar uma explosão de cardinalidade, exemplo medir o endpoint x o user-agent ( existem milhoes de user-agent)*** 

**Telemetry** gets generated from **instrumentation**, which is code or tooling that gathers data from your system in real-time. Whatever observability tool you’re using, there’s some set up and configuration to do in order to generate telemetry data and then send it off to your vendor or service

**OpenTelemetry** (abbreviated “OTel”) is an open-source, vendor-neutral integration that can be used to instrument your service to generate structured telemetry data

Observability tooling needs to support structured events, unaggregated data blobs containing whatever key-values pairs you decide to send. It needs to empower you to flow seamlessly between broad aggregates (time series graphs) and deep context (trace visualizations) and then broad aggregates again, using your structured events’ context fields to ensure that the answers you get are relevant and informative. Observability means aggregating at query-time, not at write-time, because you never know what questions you might want to ask later on.

> Reliability is a critical feature, observability is a necessary component of reliability, and open source tooling is at least A right approach, if not THE right approach.
> 

**Observability vs Monitoring**

The key differentiation between monitoring and observability is that observability is an inherent property of a system or service, rather than something someone does to the system, which is what monitoring fundamentally is. ************Na observabilidade voce está olhando algo que o sistema está te entregando, na monitoria voce está indo atrás dele.************ 

It is important to distinguish between these two terms because observability, as a property of the service you build, is your responsibility. As a service developer and owner, you have full control over the signals your system emits, how and where those signals are ingested and stored, and how they're utilized. This is in contrast to "monitoring," which may be done by others (and by you) to measure the availability and performance of your service and generate alerts to let you know that service reliability has degraded. *********************************************É de responsabilidade de quem faz o serviço colocar a observabilidade dentro dele.********************************************* 

## Tipos de métricas

Existem 4 valores de métricas que as bibliotecas exportam

### Counter

é usado em um valor que só sobe ou 0 quando resetado, basicamente é um contador usados para valores que são somados entre as iterações, nunca usar para algo que mudaria

## Gauge

valores unicos que são dinamicos, que podem subir e descer. Muito usado pra por exemplo memoria ou numeros de itens em filas e etc

### Histogram

É quando você precisa colocar as respostas que vão receber em “buckets”, exemplo respostas de 1….2…..3…..4 segundos, quando a sua resposta vier em 2 segundo ela entra no “bucket” de 2 segundos. Naturalmente ele tem um SUM e um COUNT desses  valores. 

### Summary

é quando você usar porcentagens para entender a metrica, exemplo, quando você usa tipo 95% das vezes responde em 120ms em 5 % não. Parece mais confuso de se usar, mas é melhor em relação a uma visualização rápida.